on:
  workflow_dispatch:
  push:
    tags:
      - 'v*'

permissions:
  contents: write

jobs:
  publish-assets:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Ensure release-files exists
        run: |
          if [ ! -d "release-files" ]; then
            echo "Directory release-files/ not found. Put files to upload in release-files/ and retry."
            exit 1
          fi
          echo "Files to publish:"
          find release-files -type f -maxdepth 5 -print || true

      - name: Create release and upload each file as an asset
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');

            // determine tag name: if triggered by pushing a tag use that tag, otherwise manual-<run_number>
            const ref = context.ref || '';
            const tagName = ref.startsWith('refs/tags/') ? ref.replace('refs/tags/', '') : `manual-${process.env.GITHUB_RUN_NUMBER}`;
            const releaseName = `Release ${tagName}`;
            const dir = 'release-files';
            const { owner, repo } = context.repo;

            if (!fs.existsSync(dir)) {
              core.setFailed(`Directory ${dir} does not exist`);
              return;
            }

            // recursively collect files
            function collectFiles(dirPath) {
              let results = [];
              const items = fs.readdirSync(dirPath);
              for (const item of items) {
                const full = path.join(dirPath, item);
                const stat = fs.statSync(full);
                if (stat.isFile()) results.push(full);
                else if (stat.isDirectory()) results = results.concat(collectFiles(full));
              }
              return results;
            }

            const files = collectFiles(dir);
            if (files.length === 0) {
              core.info('No files found in release-files/ to upload.');
              return;
            }

            core.info(`Using tag: ${tagName}. Creating or getting release...`);

            // create or get release (createRelease will fail if tag exists but release exists; so attempt get first)
            let release;
            try {
              const existing = await github.rest.repos.getReleaseByTag({ owner, repo, tag: tagName });
              release = existing.data;
              core.info(`Found existing release id=${release.id} for tag ${tagName}`);
            } catch (err) {
              core.info(`No existing release for tag ${tagName}, creating one.`);
              const created = await github.rest.repos.createRelease({
                owner,
                repo,
                tag_name: tagName,
                name: releaseName,
                body: `Release created by workflow for files in ${dir}`,
                draft: false,
                prerelease: false
              });
              release = created.data;
              core.info(`Created release id=${release.id}`);
            }

            // upload each file as a separate asset
            for (const filePath of files) {
              const data = fs.readFileSync(filePath);
              const fileName = path.relative(dir, filePath).replace(/\\/g, '/'); // preserve relative path in name if desired
              core.info(`Uploading ${fileName} (${data.length} bytes) ...`);
              await github.rest.repos.uploadReleaseAsset({
                owner,
                repo,
                release_id: release.id,
                name: fileName,
                data,
                headers: {
                  'content-type': 'application/octet-stream',
                  'content-length': data.length
                }
              });
              core.info(`Uploaded ${fileName}`);
            }

            core.info('All files uploaded. Check the Releases page and the "Assets" list for this release.');
